#include <Servo.h>

// === 원본과 동일한 구조 & 상수 ===
#define PIN_IR    A0       // A0 (원래 코드에서 0으로 되어 있었는데 A0로 정확히 지정)
#define PIN_LED   9
#define PIN_SERVO 10

#define _DUTY_MIN 600      // servo 0 degree (µs)
#define _DUTY_NEU 1700     // servo neutral (90 deg)
#define _DUTY_MAX 2500     // servo 180 degree (µs)

#define _DIST_MIN 100.0    // 100 mm = 10 cm
#define _DIST_MAX 250.0    // 250 mm = 25 cm

#define EMA_ALPHA 0.2      // EMA filter alpha
#define LOOP_INTERVAL 50   // ms loop interval

// 보정/안전 파라미터 (필요 시 조정)
#define SENSOR_MULT 1.0    // 거리 보정 계수 (1.0 기본). 값이 작으면 거리를 더 크게 읽음.
#define A_VALUE_MIN 10     // analog 값이 이보다 작으면 (분모 문제 등) 이상치 처리
#define A_VALUE_MAX 1000   // analog 값 범위 초과시 이상치 처리

Servo myservo;
unsigned long last_loop_time = 0;

float dist_prev = _DIST_MIN;    // EMA 이전값 (mm)
float dist_ema  = _DIST_MIN;    // EMA 현재값 (mm)

void setup() {
  pinMode(PIN_LED, OUTPUT);
  digitalWrite(PIN_LED, LOW);

  myservo.attach(PIN_SERVO);
  myservo.writeMicroseconds(_DUTY_NEU); // 초기 중립 위치

  Serial.begin(115200);
  Serial.println("Ready: LED ON only when 10cm..25cm; servo follows distance.");
  last_loop_time = millis();
}

void loop() {
  unsigned long now = millis();
  if (now - last_loop_time < LOOP_INTERVAL) return;
  last_loop_time = now;

  // --- 1) 아날로그 읽기 ---
  int a_raw = analogRead(PIN_IR); // 0..1023 (or 0..4095 depending on board)
  float dist_raw_mm = 9999.0;     // 기본: 이상치 표시 (멤버 외 거리)

  // --- 2) 안전성 검사 및 거리 계산 ---
  // 방어적 코드: 분모가 0이 되지 않도록 하고, 너무 작거나 큰 analog 값이면 "감지 없음" 처리
  if (a_raw > A_VALUE_MIN && a_raw < A_VALUE_MAX) {
    // 원래 수식: ((6762.0 / (a_value - 9.0)) - 4.0) * 10.0  -> mm 단위
    // 분모가 0에 가까운 경우 방지
    float denom = (float)a_raw - 9.0;
    if (denom > 1.0) {
      dist_raw_mm = ((6762.0 / denom) - 4.0) * 10.0; // mm
      dist_raw_mm = dist_raw_mm * SENSOR_MULT;       // 필요시 보정
    } else {
      // 너무 가까워서 식 불안정: 아주 근접(=감지 있음으로 처리 가능)
      dist_raw_mm = 20.0; // 2cm (가까움)
    }
  } else {
    // a_raw 가 범위를 벗어나면 '감지 없음'으로 처리 (LED 꺼짐, servo 중립)
    dist_raw_mm = 9999.0;
  }

  // --- 3) 유효 범위 클램프 (비정상 치 보정) ---
  if (dist_raw_mm < 4.0) dist_raw_mm = 4.0;     // IR 센서의 아주 근접 최소값
  if (dist_raw_mm > 5000.0) dist_raw_mm = 5000.0; // 지나치게 먼 값 방지

  // --- 4) EMA 필터 적용 (결과는 mm) ---
  dist_ema = EMA_ALPHA * dist_raw_mm + (1.0 - EMA_ALPHA) * dist_prev;
  dist_prev = dist_ema;

  // --- 5) LED 제어 (원하시는 정확한 동작)
  // 조건: 정확히 100mm <= dist_ema <= 250mm 일때만 ON
  // 감지 없음(9999) 또는 범위 밖이면 OFF
  bool led_on = false;
  if (dist_ema >= _DIST_MIN && dist_ema <= _DIST_MAX) {
    led_on = true;
  } else {
    led_on = false;
  }
  digitalWrite(PIN_LED, led_on ? HIGH : LOW);

  // --- 6) 서보 제어 ---
  // 동작 요구: 거리값이 유효(감지된 값)일 때는 범위 내부를 0~180도로 매핑
  // 범위 밖(너무 가깝거나 너무 멀거나 감지 없음)일 때는 가장 가까운 경계로 클램프하여 동작
  int duty;
  if (dist_ema >= _DIST_MIN && dist_ema <= _DIST_MAX) {
    // 정상 범위: 100..250 mm -> map to _DUTY_MIN.._DUTY_MAX
    float t = (dist_ema - _DIST_MIN) / (_DIST_MAX - _DIST_MIN); // 0..1
    if (t < 0.0) t = 0.0;
    if (t > 1.0) t = 1.0;
    duty = _DUTY_MIN + (int)(t * (_DUTY_MAX - _DUTY_MIN));
  } else if (dist_ema < _DIST_MIN && dist_ema < 9999.0) {
    // 너무 가까움: 서보를 최소 위치로
    duty = _DUTY_MIN;
  } else if (dist_ema > _DIST_MAX && dist_ema < 9999.0) {
    // 너무 멂: 서보를 최대 위치로
    duty = _DUTY_MAX;
  } else {
    // 감지 없음(9999) 등: 안전하게 중립 위치로
    duty = _DUTY_NEU;
  }

  // 안전 범위 보장
  duty = constrain(duty, _DUTY_MIN, _DUTY_MAX);
  myservo.writeMicroseconds(duty);

  // --- 7) 시리얼 디버깅 출력 ---
  Serial.print("Araw:"); Serial.print(a_raw);
  Serial.print("\tRaw(mm):"); Serial.print(dist_raw_mm,1);
  Serial.print("\tEMA(mm):"); Serial.print(dist_ema,1);
  Serial.print("\tLED:"); Serial.print(led_on ? "ON" : "OFF");
  Serial.print("\tServoDuty:"); Serial.print(duty);
  Serial.println();
}
